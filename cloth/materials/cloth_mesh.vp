#version 140

uniform cloth_vp
{
    mat4 view_proj;
    vec4 cloth_time;
    vec4 cloth_params;    // x=speed, y=amplitude, z=orientation (0=vertical, 1=horizontal), w=edge_influence
    vec4 cloth_velocity;  // x=vel_x, y=vel_y, z=gust_strength, w=sprite_scale
    vec4 sprite_size;     // Sprite dimensions (for displacement scaling)
    vec4 pivot_offset;    // Pivot offset (not used for mesh, but kept for compatibility)
    vec4 cloth_gravity;   // x=sag_multiplier, y=contract_multiplier (for horizontal flags)
    vec4 cloth_billow;    // x=amplitude, y=phase_offset, z=freq_multiplier, w=reserved
    vec4 cloth_noise_texture;  // x=influence (0-1), y=scroll_speed, z=scale, w=reserved
};

// Note: Vertex texture fetch not reliably supported on all hardware
// Using procedural banded noise instead for vertex displacement

// Mesh provides position and texcoord0 directly
in vec4 position;
in vec2 texcoord0;

out vec2 var_texcoord0;
out vec2 var_localuv;         // Normalized UV (0-1), used for influence calculation
out float var_cloth_time;
out vec4 var_cloth_params;
out float var_gust_strength;
out vec2 var_cloth_velocity;

void main()
{
    // For meshes, texcoord0 IS the local UV (0-1 range)
    // After mesh generator V-flip: v=1 at top, v=0 at bottom
    vec2 local_uv = texcoord0;

    // Orientation: 0 = vertical (hung from top), 1 = horizontal (hung from left)
    float orientation = cloth_params.z;

    // For vertical: "distance from anchor" = 1 - local_uv.y (anchor at top where v=1)
    // For horizontal: "distance from anchor" = local_uv.x (anchor at left where u=0)
    // After V-flip: local_uv.y=1 at top, so (1-y) = 0 at top, 1 at bottom
    float distance_from_anchor = mix(1.0 - local_uv.y, local_uv.x, orientation);

    // For vertical: "cross axis" = local_uv.x (edge influence left/right)
    // For horizontal: "cross axis" = local_uv.y (edge influence top/bottom)
    float cross_axis = mix(local_uv.x, local_uv.y, orientation);

    // Distance-based influence - starts immediately from anchor, no threshold
    // Linear influence means ALL of the cloth can move, not just the bottom portion
    float distance_factor = distance_from_anchor;

    // Edge influence - stronger sway at edges perpendicular to anchor
    float edge_factor = abs(cross_axis - 0.5) * 2.0;

    // Combined influence: base distance + edge boost
    // Edge influence adds up to 50% more movement at edges (cloth_params.w default is 0.2)
    float influence = distance_factor * (1.0 + edge_factor * cloth_params.w);

    // Add gravity effect for flags - cloth sags when not gusting
    float gust_strength = cloth_velocity.z;
    float gravity_sag = 0.0;
    float gravity_contract = 0.0;  // Horizontal contraction toward anchor
    if (orientation > 0.5) {
        // Horizontal flag: collapse downward when gust is low
        // Apply ease-in-out-circ curve for smooth acceleration/deceleration
        float t = 1.0 - gust_strength;  // collapse amount (0 = full gust, 1 = rest)
        // Ease-in-out-circ: smooth on both ends, natural cloth feel
        float collapse_factor = t < 0.5
            ? (1.0 - sqrt(1.0 - pow(2.0 * t, 2.0))) / 2.0
            : (sqrt(1.0 - pow(-2.0 * t + 2.0, 2.0)) + 1.0) / 2.0;

        // Rotation-based droop: vertices rotate around anchor based on distance
        // cloth_gravity.x = droop_angle (radians, ~1.4 = 80°, 1.57 = 90° straight down)
        // cloth_gravity.y = droop_curve (power for distance falloff, 1.0 = linear, <1 = faster droop)
        float max_angle = cloth_gravity.x;
        float droop_power = cloth_gravity.y;

        // Angle increases with distance from anchor (use power curve for control)
        float droop_angle = collapse_factor * pow(distance_factor, droop_power) * max_angle;

        // Horizontal offset from anchor (how far this vertex extends)
        float h_offset = distance_factor * sprite_size.x;

        // Rotate this offset around the anchor:
        // new_x = h_offset * cos(angle) -> displacement = h_offset * (cos(angle) - 1)
        // new_y = -h_offset * sin(angle) -> displacement = -h_offset * sin(angle)
        gravity_contract = h_offset * (cos(droop_angle) - 1.0);
        gravity_sag = -h_offset * sin(droop_angle);
    }

    // Time with speed multiplier and world-position offset
    float world_phase_offset = (position.x - position.y) * 0.00004;
    float time = cloth_time.x * cloth_params.x + world_phase_offset;

    // Two-frequency wave for organic motion (both multiples of 2π for seamless loop)
    float wave_phase_pos = mix(position.y, position.x, orientation);
    float phase = wave_phase_pos * 0.01;

    // Procedural sine wave (primary wave + second harmonic)
    float procedural_wave = sin(time * 6.283 + phase) * 0.6
                          + sin(time * 12.566 + phase * 1.5) * 0.4;

    // Z-axis billowing - phase-shifted for organic 3D motion
    // Frequencies must be integer multiples of 2π (6.283) for seamless looping
    float billow_amplitude = cloth_billow.x;
    float billow_phase_offset = cloth_billow.y * 6.283;
    float billow_cycles = max(1.0, floor(cloth_billow.z + 0.5));  // Round to nearest integer

    float z_phase = phase + billow_phase_offset;
    float procedural_z_wave = sin(time * 6.283 * billow_cycles + z_phase) * 0.7
                            + sin(time * 6.283 * (billow_cycles + 1.0) + z_phase * 1.3) * 0.3;

    // Banded noise parameters
    // Using cloth_billow.w for influence since cloth_noise_texture uniform isn't reaching vertex shader
    // cloth_billow: x=amplitude, y=phase_offset, z=freq_multiplier, w=banded_influence
    float banded_influence = cloth_billow.w;  // 0 = smooth sine, 1 = banded pattern
    float banded_scroll_speed = 1.0;  // Hardcoded for now
    float num_bands = 0.5;  // Large folds like real flag (user requested ~0.2)

    // Create procedural banded noise pattern
    // Orientation-aware: bands run perpendicular to anchor axis
    // Banner (orientation=0): horizontal bands, use local_uv.y for band position
    // Flag (orientation=1): vertical bands, use local_uv.x for band position
    float band_position = mix(local_uv.y, local_uv.x, orientation);

    // Scroll bands along flow direction (away from anchor)
    // scroll_speed=1.0 means bands complete one full scroll per time cycle
    float scroll_phase = cloth_time.x * banded_scroll_speed * 6.283;
    float scroll_direction = mix(1.0, -1.0, orientation);  // Banner: +Y, Flag: -X (rightward)

    // Calculate band phase: position along cloth * number of bands * 2π
    // Plus scrolling phase for animation
    float band_phase_xy = (band_position * num_bands * 6.283) + (scroll_phase * scroll_direction);

    // Multi-frequency banded pattern for organic look
    // All frequencies are integers so they loop cleanly
    float banded_xy = sin(band_phase_xy) * 0.5
                    + sin(band_phase_xy * 2.0 + 1.0) * 0.3
                    + sin(band_phase_xy * 3.0 + 2.5) * 0.2;

    // Separate Z bands with different phase offset for independent motion
    float band_phase_z = band_phase_xy + 2.3;  // Offset from XY
    float banded_z = sin(band_phase_z * 1.3) * 0.5
                   + sin(band_phase_z * 2.1 + 1.7) * 0.3
                   + sin(band_phase_z * 3.7 + 0.5) * 0.2;

    // Blend between smooth procedural sine and banded pattern
    float wave_value = mix(procedural_wave, banded_xy, banded_influence);
    float z_wave = mix(procedural_z_wave, banded_z, banded_influence);

    // Gust-modulated wave amplitude (0.25 baseline, up to 1.0 during gust)
    float wave_multiplier = 0.25 + gust_strength * 0.75;

    // Scale factor for displacement normalization
    float sprite_scale = cloth_velocity.w;
    if (sprite_scale <= 0.0) sprite_scale = 1.0;
    sprite_scale = min(sprite_scale, 1.0);

    // Velocity-based displacement - increased from 125 to 200 for more dramatic response
    float vel_amplitude = 200.0;
    float vel_component = mix(-cloth_velocity.x, -cloth_velocity.y, orientation);

    // Apply displacement perpendicular to anchor axis
    vec4 displaced_pos = position;
    float wave_disp = wave_value * cloth_params.y * influence * wave_multiplier * sprite_scale;
    float vel_disp = vel_component * vel_amplitude * influence * sprite_scale;
    float z_disp = z_wave * billow_amplitude * influence * wave_multiplier * sprite_scale;

    if (orientation < 0.5) {
        // Vertical cloth: displace horizontally + Z billowing
        displaced_pos.x += wave_disp + vel_disp;
        displaced_pos.z += z_disp;
    } else {
        // Horizontal cloth: displace vertically + gravity sag + Z billowing
        // Also contract horizontally toward anchor as cloth hangs
        displaced_pos.y += wave_disp + vel_disp + gravity_sag;
        displaced_pos.x += gravity_contract;
        displaced_pos.z += z_disp;
    }

    // Transform displaced position to clip space
    vec4 displaced_clip = view_proj * displaced_pos;

    gl_Position = displaced_clip;
    var_texcoord0 = texcoord0;
    var_localuv = local_uv;

    var_cloth_time = time;
    var_cloth_params = cloth_params;
    var_gust_strength = gust_strength;
    var_cloth_velocity = vec2(-cloth_velocity.x, -cloth_velocity.y);
}
